@startuml architecture
package Hardware{

    enum ZeroPowerBehavior{
        + BRAKE : ZeroPowerBehavior
        + COAST : ZeroPowerBehavior
    }

    interface ControlGroup{
        + {abstract} setPower(double) : void
        + {abstract} getEncoder() const: optional<double>
        + {abstract} setZeroPowerBehavior(ZeroPowerBehavior) : void
        + {abstract} setReversal(bool) : void
        + {abstract} getName() const : string
    }

    ZeroPowerBehavior <-- ControlGroup

    class Motor {
        - mutex : mutable mutex
        - motor : unique_ptr<TalonFX>
        - deviceID : const uint8_t
        - friendlyName : const string
        - {static} PRIMARY_CLOSED_LOOP_PID : constexpr int8_t
        - {static} ENCODER_RESET_TIMEOUT_MILISECONDS : constexpr int32_t
        
        + Motor(uint8_t, string) : Motor
    }

    ControlGroup <|.. Motor

    class CompositeControlGroup {
        - mutex : mutable mutex
        - encoderRead : shared_ptr<ControlGroup>
        - members : vector<shared_ptr<ControlGroup>>
        - name : const string

        + CompositeControlGroup(string) : CompositeControlGroup
        + addControlGroup(shared_ptr<ControlGroup>) : void
        + removeControlGroup(const ControlGroup&) : void
        + setPrimaryEncoder(shared_ptr<ControlGroup>) : void
        + getControlGroup(const string&) : ControlGroup&
        + clearGroup() : void
    }

    ControlGroup <|.. CompositeControlGroup

    class MockMotor{
        - mutex : mutable mutex
        - name : const string
        - encoder : mutable int32_t
        - speed int32_t- inversion: int32_t
        - lastEncoderCalculation : mutable time_point<steady_clock>

        + Mock Motor(const string&) : MockMotor
        - updateEncoder() const : void
    }

    ControlGroup <|.. MockMotor

}

package "ROS Handler"{
    package "ROS Handler Core"{
        abstract class RosTimedAction{
            - timer : const ros::Timer
            - expectedRate : const ros::Rate
            - actionName : const string
            - {static} TIMER_TOLERANCE_RATIO : constexpr double

            - timerCallback(const ros::TimerEvent&) : void
            # {abstract} onTimerEvent(const ros::TimerEvent&) : void
        }

        abstract class RosSubscribedAction<SubscribedType>{
            - subscriber : const ros::Subscriber
            - maxResponseTime : const ros::Duration

            - subscriberCallback(const ros::MessageEvent<const SubscribedType>&) : void
            # {abstract} onMessageReceived(const SubscribedType::ConstPtr&) : void
        }

        abstract class RosServiceAction<ServiceType>{
            - server : const ros::ServiceServer
            - maxResponseTime : const ros::Duration

            - serviceCallback(const ros::ServiceEvent<const RequestType, const ResponseType>&) : bool
            # {abstract} onMessageReceived(const RequestType&, ReplyType&) : bool
        }
        note right of RosServiceAction : Request and Reply types are autogenerated \nparts of the Service type

        abstract class ControlGroupRosTimedAction{
            # controlGroup : shared_ptr<ControlGroup>

            + ControlGroupRosTimedAction(const ros::NodeHandle&, const shared_ptr<ControlGroup>&, const string&, const ros::Rate&) : ControlGroupRosTimedAction
        }

        RosTimedAction <|.. ControlGroupRosTimedAction
        ControlGroupRosTimedAction::controlGroup "1" o--> "1" ControlGroup
    
        abstract class ControlGroupRosSubscribedAction<SubscribedType>{
            # controlGroup : shared_ptr<ControlGroup>

            + ControlGroupRosSubscribedAction(const ros::NodeHandle&, const shared_ptr<ControlGroup>&, const string&, const ros::Duration&) : ControlGroupRosSubscribedAction
        }

        RosSubscribedAction <|.. ControlGroupRosSubscribedAction
        ControlGroupRosSubscribedAction::controlGroup "1" o--> "1" ControlGroup

        abstract class ControlGroupRosServiceAction<ServiceType>{
            # controlGroup : shared_ptr<ControlGroup>

            + ControlGroupRosServiceAction(const ros::NodeHandle&, const shared_ptr<ControlGroup>&, const string&, const ros::Duration&) : ControlGroupRosServiceAction
        }

        RosServiceAction <|.. ControlGroupRosServiceAction
        ControlGroupRosServiceAction::controlGroup "1" o--> "1" ControlGroup
    }

    class EncoderTimedAction{
        - publisher : const ros::Publisher
        - {static} ENCODER_PUBLISHING_RATE_HZ : constexpr double
        - {static} ENCODER_PUBLISHING_BUFFER_SIZE : constexpr uint32_t

        + EncoderTimedActions(ros::NodeHandle&, const shared_ptr<ControlgRoup>&) : EncoderTimedAction
    }

    ControlGroupRosTimedAction <|.. EncoderTimedAction

    class PowerSubscribedAction{
        - {static} POWER_MAX_RESPONSE_DELAY_SECONDS : constexpr double
        - {static} POWER_SUBSCRIBER_QUEUE_SIZE : contexpr uint32_t

        + PowerSubscribedAction(ros::NodeHandle&, const shared_ptr<ControlGroup>&) : PowerSubscribedAction
    }

    ControlGroupRosSubscribedAction <|.. PowerSubscribedAction : SubscribedType=std::msgs_Float64

    class ReverseServiceAction{
        - {static} REVERSE_MAX_RESPONSE_DELAY_SECONDS : constexpr double
        
        + ReverseServiceAction(ros::NodeHandle&, const shared_ptr<ControlGroup>&) : ReverseServiceAction
    }

    ControlGroupRosServiceAction <|.. ReverseServiceAction : ServiceType=wrevolution::Reverse

    class ResetSettingsServiceAction{
        - {static} RESET_SETTINGS_MAX_RESPONSE_DELAY_SECONDS : constexpr double

        + ResetSettingsServiceAction(ros::NodeHandle&, const shared_ptr<ControlGroup>&) : ResetSettingsServiceAction
    }

    ControlGroupRosServiceAction <|.. ResetSettingsServiceAction : ServiceType=wrevolution::ResetSettings

    class ZeroPowerBehaviorServiceAction{
        - {static} ZERO_POWER_MAX_RESPONSE_DELAY_SECONDS : constexpr double

        + ZeroPowerBehaviorServiceAction(ros::NodeHandle&, const shared_ptr<ControlGroup>&) : ZeroPowerBehaviorServiceAction
    }

    ControlGroupRosServiceAction <|.. ZeroPowerBehaviorServiceAction : ServiceType=wrevolution::ZeroPowerBehavior

    class ControlGroupRosHandler{
        - encoderAction : unique_ptr<EncoderTimedAction>
        - powerAction : unique_ptr<PowerSubscribedAction>
        - reverseAction : unique_ptr<ReverseServiceAction>
        - resetSettingsAction : unique_ptr<ResetSettingsServiceAction>
        - zeroPowerBehaviorAction : unique_ptr<ZeroPowerBehaviorServiceAction>

        + ControlGroupRosHandler(ros::NodeHandle&, const shared_ptr<ControlGroup>&) : ControlGroupRosHandler
    }

    EncoderTimedAction "1" <--* "1" ControlGroupRosHandler
    PowerSubscribedAction "1" <--* "1" ControlGroupRosHandler
    ReverseServiceAction "1" <--* "1" ControlGroupRosHandler
    ResetSettingsServiceAction "1" <--* "1" ControlGroupRosHandler
    ZeroPowerBehaviorServiceAction "1" <--* "1" ControlGroupRosHandler

    note right of ControlGroupRosHandler : Acts as factory and reference-holder \nfor all things you could do with a \nControlGroup over ROS
}
@enduml